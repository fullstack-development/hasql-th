{-|

Our parsing strategy is to port the original Postgres parser as closely as possible.

We're using the @gram.y@ Postgres source file, which is the closest thing we have
to a Postgres syntax spec. Here's a link to it:
https://github.com/postgres/postgres/blob/master/src/backend/parser/gram.y.

Here's the essence of how the original parser is implemented, citing from
[PostgreSQL Wiki](https://wiki.postgresql.org/wiki/Developer_FAQ):

    scan.l defines the lexer, i.e. the algorithm that splits a string
    (containing an SQL statement) into a stream of tokens.
    A token is usually a single word
    (i.e., doesn't contain spaces but is delimited by spaces), 
    but can also be a whole single or double-quoted string for example. 
    The lexer is basically defined in terms of regular expressions 
    which describe the different token types.

    gram.y defines the grammar (the syntactical structure) of SQL statements,
    using the tokens generated by the lexer as basic building blocks.
    The grammar is defined in BNF notation.
    BNF resembles regular expressions but works on the level of tokens, not characters.
    Also, patterns (called rules or productions in BNF) are named, and may be recursive,
    i.e. use themselves as sub-patterns.

-}
module Hasql.TH.Syntax.Parsing where

import Hasql.TH.Prelude hiding (aExpr, try, option, some, many, sortBy, filter, head, tail)
import HeadedMegaparsec
import Control.Applicative.Combinators hiding (some)
import Control.Applicative.Combinators.NonEmpty
import Hasql.TH.Syntax.Ast
import qualified Text.Megaparsec as Mega
import qualified Text.Megaparsec.Char as Mega
import qualified Text.Megaparsec.Char.Lexer as Lex
import qualified Hasql.TH.Syntax.Predicate as Predicate
import qualified Hasql.TH.Syntax.HashSet as HashSet
import qualified Data.Text as Text
import qualified Text.Builder as TextBuilder


{- $setup
>>> testParser parser = parseTest (parser <* eof)
-}


type Parser = HeadedParsec Void Text


-- * Executors
-------------------------

parse :: Parser a -> Text -> Either Text a
parse p = first (fromString . Mega.errorBundlePretty) . Mega.runParser (toParsec p <* Mega.eof) ""


-- * Helpers
-------------------------

commaSeparator :: Parser ()
commaSeparator = head (Mega.space *> Mega.char ',') *> tail (Mega.space)

dotSeparator :: Parser ()
dotSeparator = head (Mega.space *> Mega.char '.') *> tail (Mega.space)

inParens :: Parser a -> Parser a
inParens p = char '(' *> space *> p <* endHead <* space <* char ')'

inParensWithLabel :: (label -> content -> result) -> Parser label -> Parser content -> Parser result
inParensWithLabel _result _labelParser _contentParser = do
  _label <- headify _labelParser <* head (Mega.space <* Mega.char '(')
  tail Mega.space
  _content <- _contentParser
  tail (Mega.space <* Mega.char ')')
  pure (_result _label _content)

inParensWithClause :: Parser clause -> Parser content -> Parser content
inParensWithClause = inParensWithLabel (const id)

nonEmptyList :: Parser a -> Parser (NonEmpty a)
nonEmptyList p = (:|) <$> (p <* endHead) <*> many (commaSeparator *> p)

sepWithSpace1 :: Parser a -> Parser (NonEmpty a)
sepWithSpace1 _parser = do
  _head <- _parser
  endHead
  _tail <- many $ space1 *> _parser
  return (_head :| _tail)

sepEnd1 :: Parser separator -> Parser end -> Parser el -> Parser (NonEmpty el, end)
sepEnd1 sepP endP elP = do
  headEl <- elP
  let
    loop !list = do
      sepP
      asum [
          do
            end <- endP
            return (headEl :| reverse list, end)
          ,
          do
            el <- elP
            loop (el : list)
        ]
    in loop []

{-|
>>> testParser (quotedString '\'') "'abc''d'"
"abc'd"
-}
quotedString :: Char -> Parser Text
quotedString q = do
  char q
  _tail <- tail $ let
    collectChunks !bdr = do
      chunk <- Mega.takeWhileP Nothing (/= q)
      let bdr' = bdr <> TextBuilder.text chunk
      Mega.try (consumeEscapedQuote bdr') <|> finish bdr'
    consumeEscapedQuote bdr = do
      Mega.char q
      Mega.char q
      collectChunks (bdr <> TextBuilder.char q)
    finish bdr = do
      Mega.char q
      return (TextBuilder.run bdr)
    in collectChunks mempty
  return _tail

quasiQuote :: Parser a -> Parser a
quasiQuote p = space *> p <* endHead <* space <* eof


-- * PreparableStmt
-------------------------

preparableStmt :: Parser PreparableStmt
preparableStmt = selectPreparableStmt

selectPreparableStmt :: Parser PreparableStmt
selectPreparableStmt = SelectPreparableStmt <$> selectStmt


-- * Select
-------------------------

selectStmt :: Parser SelectStmt
selectStmt = Right <$> selectWithParens <|> Left <$> selectNoParens

selectWithParens = inParens (WithParensSelectWithParens <$> selectWithParens <|> NoParensSelectWithParens <$> selectNoParens)

selectNoParens :: Parser SelectNoParens
selectNoParens = withSelectNoParens <|> simpleSelectNoParens

sharedSelectNoParens _with = do
  _select <- selectClause
  _sort <- optional (space1 *> sortClause)
  _limit <- optional (space1 *> selectLimit)
  _forLocking <- optional (space1 *> forLockingClause)
  return (SelectNoParens _with _select _sort _limit _forLocking)

{-|
The one that doesn't start with \"WITH\".
-}
{-
  | simple_select
  | select_clause sort_clause
  | select_clause opt_sort_clause for_locking_clause opt_select_limit
  | select_clause opt_sort_clause select_limit opt_for_locking_clause
-}
simpleSelectNoParens = sharedSelectNoParens Nothing

withSelectNoParens = do
  _with <- withClause
  space1
  sharedSelectNoParens (Just _with)

selectClause = do
  a <- asum [
      Right <$> selectWithParens,
      Left <$> headfulSimpleSelect
    ]
  asum [
      Left <$> headlessSimpleSelect a,
      pure a
    ]

{-|
>>> test = testParser simpleSelect

>>> test "select"
NormalSimpleSelect Nothing Nothing Nothing Nothing Nothing Nothing Nothing

>>> test "select distinct 1"
...DistinctTargeting Nothing (ExprTarget (LiteralExpr (IntLiteral 1)) Nothing :| [])...

>>> test "select $1"
...NormalTargeting (ExprTarget (PlaceholderExpr 1) Nothing :| [])...

>>> test "select $1 + $2"
...BinOpExpr "+" (PlaceholderExpr 1) (PlaceholderExpr 2)...

>>> test "select a, b"
...ExprTarget (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "a"))) Nothing :| [ExprTarget (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "b"))) Nothing]...

>>> test "select $1 :: text"
...TypecastExpr (PlaceholderExpr 1) (Type "text" False 0 False)...

>>> test "select 1"
...ExprTarget (LiteralExpr (IntLiteral 1))...

>>> test "select id"
...ExprTarget (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "id"))) Nothing...

>>> test "select id from user"
1:20:
  |
1 | select id from user
  |                    ^
Reserved keyword "user" used as an identifier. If that's what you intend, you have to wrap it in double quotes.

>>> test "select id :: int4 from \"user\""
...TypecastExpr (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "id"))) (Type "int4" False 0 False)...
-}
{-
simple_select:
  |  SELECT opt_all_clause opt_target_list
      into_clause from_clause where_clause
      group_clause having_clause window_clause
  |  SELECT distinct_clause target_list
      into_clause from_clause where_clause
      group_clause having_clause window_clause
  |  values_clause
  |  TABLE relation_expr
  |  select_clause UNION all_or_distinct select_clause
  |  select_clause INTERSECT all_or_distinct select_clause
  |  select_clause EXCEPT all_or_distinct select_clause
-}

headfulSimpleSelect :: Parser SimpleSelect
headfulSimpleSelect = asum [
    do
      string' "select"
      head $ Mega.notFollowedBy $ Mega.satisfy $ isAlphaNum
      endHead
      _targeting <- optional (space1 *> targeting)
      _intoClause <- optional (space1 *> string' "into" *> endHead *> space1 *> optTempTableName)
      _fromClause <- optional (space1 *> string' "from" *> endHead *> space1 *> nonEmptyList tableRef)
      _whereClause <- optional (space1 *> string' "where" *> endHead *> space1 *> aExpr)
      _groupClause <- optional (space1 *> keyphrase "group by" *> endHead *> space1 *> nonEmptyList groupByItem)
      _havingClause <- optional (space1 *> string' "having" *> endHead *> space1 *> aExpr)
      _windowClause <- optional (space1 *> string' "window" *> endHead *> space1 *> nonEmptyList windowDefinition)
      return (NormalSimpleSelect _targeting _intoClause _fromClause _whereClause _groupClause _havingClause _windowClause)
    ,
    ValuesSimpleSelect <$> valuesClause
  ]

headlessSimpleSelect :: SelectClause -> Parser SimpleSelect
headlessSimpleSelect _headSelectClause = do
  _op <- space1 *> selectBinOp <* space1
  endHead
  _allOrDistinct <- optional (allOrDistinct <* space1)
  _selectClause <- selectClause
  return (BinSimpleSelect _op _headSelectClause _allOrDistinct _selectClause)
  
allOrDistinct = string' "all" $> False <|> string' "distinct" $> True

selectBinOp = asum [
    string' "union" $> UnionSelectBinOp,
    string' "intersect" $> IntersectSelectBinOp,
    string' "except" $> ExceptSelectBinOp
  ]

valuesClause = nonEmptyList $ do
  string' "values"
  space
  char '('
  endHead
  space
  _a <- nonEmptyList aExpr
  space
  char ')'
  return _a

withClause = label "with clause" $ do
  string' "with"
  space1
  endHead
  _recursive <- option False (True <$ string' "recursive" <* space1)
  _cteList <- nonEmptyList commonTableExpr
  return (WithClause _recursive _cteList)

commonTableExpr = label "common table expression" $ do
  _name <- colId <* space <* endHead
  _nameList <- optional (inParens (nonEmptyList colId) <* space1)
  string' "as"
  space1
  _materialized <- optional (materialized <* space1)
  _stmt <- inParens preparableStmt
  return (CommonTableExpr _name _nameList _materialized _stmt)

materialized =
  True <$ string' "materialized" <|>
  False <$ keyphrase "not materialized"

{-
simple_select:
  |  SELECT opt_all_clause opt_target_list
      into_clause from_clause where_clause
      group_clause having_clause window_clause
  |  SELECT distinct_clause target_list
      into_clause from_clause where_clause
      group_clause having_clause window_clause

distinct_clause:
  |  DISTINCT
  |  DISTINCT ON '(' expr_list ')'
-}
targeting :: Parser Targeting
targeting = distinct <|> allWithTargetList <|> all <|> normal where
  normal = NormalTargeting <$> targetList
  allWithTargetList = do
    string' "all"
    space1
    endHead
    AllTargeting <$> Just <$> targetList
  all = string' "all" $> AllTargeting Nothing
  distinct = do
    string' "distinct"
    space1
    endHead
    _optOn <- optional (onExpressionsClause <* space1)
    _targetList <- targetList
    return (DistinctTargeting _optOn _targetList)

targetList :: Parser (NonEmpty Target)
targetList = nonEmptyList target

{-|
>>> testParser target "a.b as c"
ExprTarget (QualifiedNameExpr (IndirectedQualifiedName (UnquotedName "a") (AttrNameIndirectionEl (UnquotedName "b") :| []))) (Just (UnquotedName "c"))
-}
{-
target_el:
  |  a_expr AS ColLabel
  |  a_expr IDENT
  |  a_expr
  |  '*'
-}
target :: Parser Target
target = label "target" $ exprCase <|> allCase where
  allCase = AllTarget <$ char '*'
  exprCase = do
    _expr <- aExpr
    endHead
    _optAlias <- optional $ asum [
        do
          space1
          string' "as"
          space1
          endHead
          colLabel
        ,
        space1 *> ident
      ]
    return (ExprTarget _expr _optAlias)

onExpressionsClause :: Parser (NonEmpty Expr)
onExpressionsClause = do
  string' "on"
  space1
  endHead
  nonEmptyList aExpr


-- * Into clause details
-------------------------

{-
OptTempTableName:
  | TEMPORARY opt_table qualified_name
  | TEMP opt_table qualified_name
  | LOCAL TEMPORARY opt_table qualified_name
  | LOCAL TEMP opt_table qualified_name
  | GLOBAL TEMPORARY opt_table qualified_name
  | GLOBAL TEMP opt_table qualified_name
  | UNLOGGED opt_table qualified_name
  | TABLE qualified_name
  | qualified_name
-}
optTempTableName :: Parser OptTempTableName
optTempTableName = asum [
    do
      a <- asum [
          TemporaryOptTempTableName <$ string' "temporary" <* space1,
          TempOptTempTableName <$ string' "temp" <* space1,
          LocalTemporaryOptTempTableName <$ string' "local temporary" <* space1,
          LocalTempOptTempTableName <$ string' "local temp" <* space1,
          GlobalTemporaryOptTempTableName <$ string' "global temporary" <* space1,
          GlobalTempOptTempTableName <$ string' "global temp" <* space1,
          UnloggedOptTempTableName <$ string' "unlogged" <* space1
        ]
      b <- option False (True <$ string' "table" <* space1)
      c <- qualifiedName
      return (a b c)
    ,
    do
      string' "table"
      space1
      endHead
      TableOptTempTableName <$> qualifiedName
    ,
    QualifedOptTempTableName <$> qualifiedName
  ]


-- * Group by details
-------------------------

groupByItem :: Parser GroupByItem
groupByItem = asum [
    EmptyGroupingSetGroupByItem <$ (char '(' *> space *> char ')'),
    RollupGroupByItem <$> (string' "rollup" *> endHead *> space *> inParens (nonEmptyList aExpr)),
    CubeGroupByItem <$> (string' "cube" *> endHead *> space *> inParens (nonEmptyList aExpr)),
    GroupingSetsGroupByItem <$> (keyphrase "grouping sets" *> endHead *> space *> inParens (nonEmptyList groupByItem)),
    ExprGroupByItem <$> aExpr
  ]


-- * Window clause details
-------------------------

windowDefinition :: Parser WindowDefinition
windowDefinition = WindowDefinition <$> (colId <* space1 <* string' "as" <* space1 <* endHead) <*> windowSpecification

{-
window_specification:
  |  '(' opt_existing_window_name opt_partition_clause
            opt_sort_clause opt_frame_clause ')'
-}
windowSpecification :: Parser WindowSpecification
windowSpecification = inParens $ asum [
    do
      a <- frameClause
      return (WindowSpecification Nothing Nothing Nothing (Just a))
    ,
    do
      a <- sortClause
      b <- optional (space1 *> frameClause)
      return (WindowSpecification Nothing Nothing (Just a) b)
    ,
    do
      a <- partitionByClause
      b <- optional (space1 *> sortClause)
      c <- optional (space1 *> frameClause)
      return (WindowSpecification Nothing (Just a) b c)
    ,
    do
      a <- colId
      b <- optional (space1 *> partitionByClause)
      c <- optional (space1 *> sortClause)
      d <- optional (space1 *> frameClause)
      return (WindowSpecification (Just a) b c d)
  ]

partitionByClause = keyphrase "partition by" *> space1 *> endHead *> nonEmptyList aExpr

{-
opt_frame_clause:
  |  RANGE frame_extent opt_window_exclusion_clause
  |  ROWS frame_extent opt_window_exclusion_clause
  |  GROUPS frame_extent opt_window_exclusion_clause
  |  EMPTY
-}
frameClause = do
  a <- frameClauseMode <* space1 <* endHead
  b <- frameExtent
  c <- optional (space1 *> windowExclusionClause)
  return (FrameClause a b c)

frameClauseMode = asum [
    RangeFrameClauseMode <$ string' "range",
    RowsFrameClauseMode <$ string' "rows",
    GroupsFrameClauseMode <$ string' "groups"
  ]

frameExtent =
  BetweenFrameExtent <$> (string' "between" *> space1 *> endHead *> frameBound <* space1 <* string' "and" <* space1) <*> frameBound <|>
  SingularFrameExtent <$> frameBound

{-
  |  UNBOUNDED PRECEDING
  |  UNBOUNDED FOLLOWING
  |  CURRENT_P ROW
  |  a_expr PRECEDING
  |  a_expr FOLLOWING
-}
frameBound =
  UnboundedPrecedingFrameBound <$ keyphrase "unbounded preceding" <|>
  UnboundedFollowingFrameBound <$ keyphrase "unbounded following" <|>
  CurrentRowFrameBound <$ keyphrase "current row" <|>
  PrecedingFrameBound <$> (aExpr <* string' "preceding") <|>
  FollowingFrameBound <$> (aExpr <* string' "following")

windowExclusionClause =
  CurrentRowWindowExclusionClause <$ keyphrase "exclude current row" <|>
  GroupWindowExclusionClause <$ keyphrase "exclude group" <|>
  TiesWindowExclusionClause <$ keyphrase "exclude ties" <|>
  NoOthersWindowExclusionClause <$ keyphrase "exclude no others"


-- * Table refs
-------------------------

{-|
>>> testParser tableRef "a left join b "
...
expecting "on", "using", or white space

>>> testParser tableRef "a left join b on (a.i = b.i)"
JoinTableRef (MethJoinedTable (QualJoinMeth...

-}
{-
| relation_expr opt_alias_clause
| relation_expr opt_alias_clause tablesample_clause
| func_table func_alias_clause
| LATERAL_P func_table func_alias_clause
| xmltable opt_alias_clause
| LATERAL_P xmltable opt_alias_clause
| select_with_parens opt_alias_clause
| LATERAL_P select_with_parens opt_alias_clause
| joined_table
| '(' joined_table ')' alias_clause

TODO: Add support for missing cases.
-}
tableRef :: Parser TableRef
tableRef = label "table reference" $ do
  _tr <- nonTrailingTableRef
  trailingTableRef _tr <|> pure _tr
  where
    
    nonTrailingTableRef = asum [
        relationExprTableRef <|>
        lateralTableRef <|> nonLateralTableRef <|>
        inParensJoinedTableTableRef <|>
        joinedTableWithAliasTableRef
      ]
      where
        
        {-
        | relation_expr opt_alias_clause
        | relation_expr opt_alias_clause tablesample_clause

        TODO: Add support for TABLESAMPLE.
        -}
        relationExprTableRef = do
          _relationExpr <- relationExpr
          endHead
          _optAliasClause <- optional $ space1 *> aliasClause
          return (RelationExprTableRef _relationExpr _optAliasClause)

        {-
        | LATERAL_P func_table func_alias_clause
        | LATERAL_P xmltable opt_alias_clause
        | LATERAL_P select_with_parens opt_alias_clause
        -}
        lateralTableRef = do
          string' "lateral"
          endHead
          space1
          selectWithParensTableRef True

        nonLateralTableRef = selectWithParensTableRef False

        selectWithParensTableRef _lateral = do
          _select <- selectWithParens
          _optAliasClause <- optional $ space1 *> aliasClause
          return (SelectTableRef _lateral _select _optAliasClause)

        inParensJoinedTableTableRef = JoinTableRef <$> inParensJoinedTable <*> pure Nothing

        joinedTableWithAliasTableRef = do
          _joinedTable <- inParens joinedTable
          space1
          _alias <- aliasClause
          return (JoinTableRef _joinedTable (Just _alias))

    trailingTableRef _tableRef =
      JoinTableRef <$> tableRefJoinedTableAfterSpace _tableRef <*> pure Nothing

{-
| qualified_name
| qualified_name '*'
| ONLY qualified_name
| ONLY '(' qualified_name ')'
-}
relationExpr :: Parser RelationExpr
relationExpr =
  label "relation expression" $
  asum
    [
      do
        string' "only"
        space1
        _name <- qualifiedName
        return (OnlyRelationExpr _name False) 
      ,
      inParensWithClause (string' "only") qualifiedName <&> \ a -> OnlyRelationExpr a True
      ,
      do
        _name <- qualifiedName
        _asterisk <- asum
          [
            True <$ (space1 *> char '*'),
            pure False
          ]
        return (SimpleRelationExpr _name _asterisk)
    ]

joinedTable =
  asum [
      inParensJoinedTable,
      do
        _tr1 <- tableRef
        tableRefJoinedTableAfterSpace _tr1
    ]

{-
  | '(' joined_table ')'
-}
inParensJoinedTable = InParensJoinedTable <$> inParens joinedTable

{-
  | table_ref CROSS JOIN table_ref
  | table_ref join_type JOIN table_ref join_qual
  | table_ref JOIN table_ref join_qual
  | table_ref NATURAL join_type JOIN table_ref
  | table_ref NATURAL JOIN table_ref
-}
tableRefJoinedTableAfterSpace _tr1 = asum $
  [
    do
      space1 *> keyphrase "cross join"
      endHead
      space1
      _tr2 <- tableRef
      return (MethJoinedTable CrossJoinMeth _tr1 _tr2)
    ,
    do
      _jt <- joinTypedJoinAfterSpace
      endHead
      space1
      _tr2 <- tableRef
      space1
      _jq <- joinQual
      return (MethJoinedTable (QualJoinMeth _jt _jq) _tr1 _tr2)
    ,
    do
      space1 *> string' "natural"
      endHead
      _jt <- joinTypedJoinAfterSpace
      space1
      _tr2 <- tableRef
      return (MethJoinedTable (NaturalJoinMeth _jt) _tr1 _tr2)
  ]
  where
    joinTypedJoinAfterSpace =
      Just <$> ((space1 *> joinType <* endHead) <* space1 <* string' "join") <|>
      Nothing <$ (space1 *> string' "join")

joinType = asum [
    do
      string' "full"
      endHead
      _outer <- outerAfterSpace
      return (FullJoinType _outer)
    ,
    do
      string' "left"
      endHead
      _outer <- outerAfterSpace
      return (LeftJoinType _outer)
    ,
    do
      string' "right"
      endHead
      _outer <- outerAfterSpace
      return (RightJoinType _outer)
    ,
    string' "inner" $> InnerJoinType
  ]
  where
    outerAfterSpace = (space1 *> string' "outer") $> True <|> pure False

joinQual = asum
  [
    string' "using" *> space1 *> inParens (nonEmptyList colId) <&> UsingJoinQual
    ,
    string' "on" *> space1 *> aExpr <&> OnJoinQual
  ]

{-
alias_clause:
  |  AS ColId '(' name_list ')'
  |  AS ColId
  |  ColId '(' name_list ')'
  |  ColId
name_list:
  |  name
  |  name_list ',' name
name:
  |  ColId
-}
aliasClause :: Parser AliasClause
aliasClause = do
  _alias <- (string' "as" *> space1 *> endHead *> colId) <|> colId
  _columnAliases <- optional (space1 *> inParens (nonEmptyList colId))
  return (AliasClause _alias _columnAliases)


-- * Expressions
-------------------------
{-

a_expr:
  | c_expr
  | a_expr TYPECAST Typename
  | a_expr COLLATE any_name
  | a_expr AT TIME ZONE a_expr
  | '+' a_expr
  | '-' a_expr
  | a_expr '+' a_expr
  | a_expr '-' a_expr
  | a_expr '*' a_expr
  | a_expr '/' a_expr
  | a_expr '%' a_expr
  | a_expr '^' a_expr
  | a_expr '<' a_expr
  | a_expr '>' a_expr
  | a_expr '=' a_expr
  | a_expr LESS_EQUALS a_expr
  | a_expr GREATER_EQUALS a_expr
  | a_expr NOT_EQUALS a_expr
  | a_expr qual_Op a_expr
  | qual_Op a_expr
  | a_expr qual_Op
  | a_expr AND a_expr
  | a_expr OR a_expr
  | NOT a_expr
  | NOT_LA a_expr
  | a_expr LIKE a_expr
  | a_expr LIKE a_expr ESCAPE a_expr
  | a_expr NOT_LA LIKE a_expr
  | a_expr NOT_LA LIKE a_expr ESCAPE a_expr
  | a_expr ILIKE a_expr
  | a_expr ILIKE a_expr ESCAPE a_expr
  | a_expr NOT_LA ILIKE a_expr
  | a_expr NOT_LA ILIKE a_expr ESCAPE a_expr
  | a_expr SIMILAR TO a_expr
  | a_expr SIMILAR TO a_expr ESCAPE a_expr
  | a_expr NOT_LA SIMILAR TO a_expr
  | a_expr NOT_LA SIMILAR TO a_expr ESCAPE a_expr
  | a_expr IS NULL_P
  | a_expr ISNULL
  | a_expr IS NOT NULL_P
  | a_expr NOTNULL
  | row OVERLAPS row
  | a_expr IS TRUE_P
  | a_expr IS NOT TRUE_P
  | a_expr IS FALSE_P
  | a_expr IS NOT FALSE_P
  | a_expr IS UNKNOWN
  | a_expr IS NOT UNKNOWN
  | a_expr IS DISTINCT FROM a_expr
  | a_expr IS NOT DISTINCT FROM a_expr
  | a_expr IS OF '(' type_list ')'
  | a_expr IS NOT OF '(' type_list ')'
  | a_expr BETWEEN opt_asymmetric b_expr AND a_expr
  | a_expr NOT_LA BETWEEN opt_asymmetric b_expr AND a_expr
  | a_expr BETWEEN SYMMETRIC b_expr AND a_expr
  | a_expr NOT_LA BETWEEN SYMMETRIC b_expr AND a_expr
  | a_expr IN_P in_expr
  | a_expr NOT_LA IN_P in_expr
  | a_expr subquery_Op sub_type select_with_parens
  | a_expr subquery_Op sub_type '(' a_expr ')'
  | UNIQUE select_with_parens
  | a_expr IS DOCUMENT_P
  | a_expr IS NOT DOCUMENT_P
  | DEFAULT

b_expr:
  | c_expr
  | b_expr TYPECAST Typename
  | '+' b_expr
  | '-' b_expr
  | b_expr '+' b_expr
  | b_expr '-' b_expr
  | b_expr '*' b_expr
  | b_expr '/' b_expr
  | b_expr '%' b_expr
  | b_expr '^' b_expr
  | b_expr '<' b_expr
  | b_expr '>' b_expr
  | b_expr '=' b_expr
  | b_expr LESS_EQUALS b_expr
  | b_expr GREATER_EQUALS b_expr
  | b_expr NOT_EQUALS b_expr
  | b_expr qual_Op b_expr
  | qual_Op b_expr
  | b_expr qual_Op
  | b_expr IS DISTINCT FROM b_expr
  | b_expr IS NOT DISTINCT FROM b_expr
  | b_expr IS OF '(' type_list ')'
  | b_expr IS NOT OF '(' type_list ')'
  | b_expr IS DOCUMENT_P
  | b_expr IS NOT DOCUMENT_P

-}


exprListInParens = inParens (nonEmptyList aExpr)

{-|
Notice that the tree constructed by this parser does not reflect
the precedence order of Postgres.
For the purposes of this library it simply doesn't matter,
so we're not bothering with that.

Composite on the right:
>>> testParser aExpr "$1 = $2 :: int4"
BinOpExpr "=" (PlaceholderExpr 1) (TypecastExpr (PlaceholderExpr 2) (Type "int4" False 0 False))

Composite on the left:
>>> testParser aExpr "$1 = $2 :: int4 and $3"
BinOpExpr "=" (PlaceholderExpr 1) (BinOpExpr "and" (TypecastExpr (PlaceholderExpr 2) (Type "int4" False 0 False)) (PlaceholderExpr 3))
-}
aExpr :: Parser Expr
aExpr = label "expression" $ do
  _left <- terminatingExpr
  loopingExpr _left <|> pure _left
  where
    loopingExpr _left = do
      _expr <- asum
        [
          typecastExpr _left,
          binOpExpr _left,
          escapableBinOpExpr _left
        ]
      loopingExpr _expr <|> pure _expr
    terminatingExpr = defaultExpr <|> cExpr

{-
c_expr:
  | columnref
  | AexprConst
  | PARAM opt_indirection
  | '(' a_expr ')' opt_indirection
  | case_expr
  | func_expr
  | select_with_parens
  | select_with_parens indirection
  | EXISTS select_with_parens
  | ARRAY select_with_parens
  | ARRAY array_expr
  | explicit_row
  | implicit_row
  | GROUPING '(' expr_list ')'

TODO: Add missing cases.
-}
cExpr :: Parser Expr
cExpr =
  asum
    [
      placeholderExpr,
      headify funcExpr,
      literalExpr,
      inParensExpr,
      caseExpr,
      existsSelectExpr,
      arraySelectExpr,
      groupingExpr,
      columnRefExpr
    ]

placeholderExpr :: Parser Expr
placeholderExpr = PlaceholderExpr <$> (char '$' *> head Lex.decimal)

inParensExpr :: Parser Expr
inParensExpr = InParensExpr <$> (Left <$> inParens aExpr <|> Right <$> selectWithParens) <*> optional (space *> indirection)

typecastExpr :: Expr -> Parser Expr
typecastExpr _left = do
  space
  string "::"
  endHead
  space
  _type <- type_
  return (TypecastExpr _left _type)

binOpExpr :: Expr -> Parser Expr
binOpExpr _a = do
  _binOp <- label "binary operator" (space *> symbolicBinOp <* space <|> space1 *> lexicalBinOp <* space1)
  _b <- aExpr
  return (BinOpExpr _binOp _a _b)

symbolicBinOp :: Parser Text
symbolicBinOp =
  takeWhile1P Nothing Predicate.symbolicBinOpChar &
  filter (\ a -> "Unknown binary operator: " <> show a) (Predicate.inSet HashSet.symbolicBinOp)

lexicalBinOp :: Parser Text
lexicalBinOp = asum $ fmap keyphrase $ ["and", "or", "is distinct from", "is not distinct from"]

escapableBinOpExpr :: Expr -> Parser Expr
escapableBinOpExpr _a = do
  space1
  _not <- option False $ True <$ string' "not" <* space1
  _op <- asum $ fmap keyphrase $ ["like", "ilike", "similar to"]
  space1
  endHead
  _b <- aExpr
  _escaping <- optional $ do
    space1
    string' "escape"
    space1
    endHead
    _c <- aExpr
    return _c
  return (EscapableBinOpExpr _not (Text.toUpper _op) _a _b _escaping)

defaultExpr :: Parser Expr
defaultExpr = DefaultExpr <$ string' "default"

columnRefExpr :: Parser Expr
columnRefExpr = QualifiedNameExpr <$> columnRef

literalExpr :: Parser Expr
literalExpr = LiteralExpr <$> literal

{-|
Full specification:

>>> testParser caseExpr "CASE WHEN a = b THEN c WHEN d THEN e ELSE f END"
CaseExpr Nothing (WhenClause (BinOpExpr "=" (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "a"))) (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "b")))) (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "c"))) :| [WhenClause (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "d"))) (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "e")))]) (Just (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "f"))))

Implicit argument:

>>> testParser caseExpr "CASE a WHEN b THEN c ELSE d END"
CaseExpr (Just (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "a")))) (WhenClause (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "b"))) (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "c"))) :| []) (Just (QualifiedNameExpr (SimpleQualifiedName (UnquotedName "d"))))
-}
caseExpr :: Parser Expr
caseExpr = label "case expression" $ do
  string' "case"
  space1
  endHead
  _arg <- optional (aExpr <* space1)
  _whenClauses <- sepWithSpace1 whenClause
  space1
  _default <- optional elseClause
  string' "end"
  pure $ CaseExpr _arg _whenClauses _default

whenClause :: Parser WhenClause
whenClause = do
  string' "when"
  space1
  endHead
  _a <- aExpr
  space1
  string' "then"
  space1
  _b <- aExpr
  return (WhenClause _a _b)

elseClause = do
  string' "else"
  space1
  endHead
  a <- aExpr
  space1
  return a

{-
func_expr:
  | func_application within_group_clause filter_clause over_clause
  | func_expr_common_subexpr
TODO: Handle the remaining stuff
-}
funcExpr :: Parser Expr
funcExpr = FuncExpr <$> funcApplication

funcApplication :: Parser FuncApplication
funcApplication = inParensWithLabel FuncApplication funcName (optional funcApplicationParams)

funcApplicationParams :: Parser FuncApplicationParams
funcApplicationParams =
  asum
    [
      starFuncApplicationParams,
      listVariadicFuncApplicationParams,
      singleVariadicFuncApplicationParams,
      normalFuncApplicationParams
    ]

normalFuncApplicationParams :: Parser FuncApplicationParams
normalFuncApplicationParams = do
  _optAllOrDistinct <- optional (allOrDistinct <* space1)
  _argList <- nonEmptyList funcArgExpr
  endHead
  _optSortClause <- optional (space1 *> sortClause)
  return (NormalFuncApplicationParams _optAllOrDistinct _argList _optSortClause)

singleVariadicFuncApplicationParams :: Parser FuncApplicationParams
singleVariadicFuncApplicationParams = do
  string' "variadic"
  space1
  endHead
  _arg <- funcArgExpr
  _optSortClause <- optional (space1 *> sortClause)
  return (VariadicFuncApplicationParams Nothing _arg _optSortClause)

listVariadicFuncApplicationParams :: Parser FuncApplicationParams
listVariadicFuncApplicationParams = do
  (_argList, _) <- sepEnd1 commaSeparator (string' "variadic" <* space1) funcArgExpr
  endHead
  _arg <- funcArgExpr
  _optSortClause <- optional (space1 *> sortClause)
  return (VariadicFuncApplicationParams (Just _argList) _arg _optSortClause)

starFuncApplicationParams :: Parser FuncApplicationParams
starFuncApplicationParams = space *> char '*' *> endHead *> space $> StarFuncApplicationParams

{-
func_arg_expr:
  | a_expr
  | param_name COLON_EQUALS a_expr
  | param_name EQUALS_GREATER a_expr
param_name:
  | type_function_name
-}
funcArgExpr :: Parser FuncArgExpr
funcArgExpr = asum [
    do
      a <- typeFuncName
      space
      asum [
          do
            string ":="
            endHead
            b <- space *> aExpr
            return (ColonEqualsFuncArgExpr a b)
          ,
          do
            string "=>"
            endHead
            b <- space *> aExpr
            return (EqualsGreaterFuncArgExpr a b)
        ]
    ,
    ExprFuncArgExpr <$> aExpr
  ]

sortClause :: Parser (NonEmpty SortBy)
sortClause = do
  keyphrase "order by"
  endHead
  space1
  a <- nonEmptyList sortBy
  return a

sortBy :: Parser SortBy
sortBy = do
  _expr <- aExpr
  _optOrder <- optional (space1 *> order)
  return (SortBy _expr _optOrder)

order :: Parser Order
order = string' "asc" $> AscOrder <|> string' "desc" $> DescOrder

existsSelectExpr :: Parser Expr
existsSelectExpr = string' "array" *> space *> (ExistsSelectExpr <$> selectWithParens)

arraySelectExpr :: Parser Expr
arraySelectExpr = string' "array" *> space *> (ArraySelectExpr <$> selectWithParens)

groupingExpr :: Parser Expr
groupingExpr = inParensWithClause (string' "grouping") (GroupingExpr <$> nonEmptyList aExpr)


-- * Literals
-------------------------

{-|
@
AexprConst: Iconst
      | FCONST
      | Sconst
      | BCONST
      | XCONST
      | func_name Sconst
      | func_name '(' func_arg_list opt_sort_clause ')' Sconst
      | ConstTypename Sconst
      | ConstInterval Sconst opt_interval
      | ConstInterval '(' Iconst ')' Sconst
      | TRUE_P
      | FALSE_P
      | NULL_P
@

>>> testParser literal "- 324098320984320480392480923842"
IntLiteral (-324098320984320480392480923842)

>>> testParser literal "'abc''de'"
StringLiteral "abc'de"

>>> testParser literal "23.43234"
FloatLiteral 23.43234

>>> testParser literal "-32423423.3243248732492739847923874"
FloatLiteral -3.24234233243248732492739847923874e7

>>> testParser literal "NULL"
NullLiteral
-}
{- TODO: Add remaining cases -}
literal :: Parser Literal
literal = asum [
    do
      string' "interval"
      space1
      endHead
      a <- asum [
          do
            a <- sconst
            endHead
            b <- optional (space1 *> interval)
            return (StringIntervalLiteral a b)
          ,
          do
            a <- inParens iconst
            space1
            endHead
            b <- sconst
            return (IntIntervalLiteral a b)
        ]
      return a
    ,
    do
      a <- constTypename
      space1
      endHead
      b <- sconst
      return (ConstTypenameLiteral a b)
    ,
    BoolLiteral True <$ string' "true"
    ,
    BoolLiteral False <$ string' "false"
    ,
    NullLiteral <$ string' "null"
    ,
    either IntLiteral FloatLiteral <$> iconstOrFconst
    ,
    StringLiteral <$> sconst
    ,
    label "bit literal" $ do
      string' "b'"
      endHead
      a <- takeWhile1P (Just "0 or 1") (\ b -> b == '0' || b == '1')
      char '\''
      return (BitLiteral a)
    ,
    label "hex literal" $ do
      string' "x'"
      endHead
      a <- takeWhile1P (Just "Hex digit") (Predicate.inSet HashSet.hexDigitChars)
      char '\''
      return (HexLiteral a)
    ,
    do
      a <- headify funcName
      space
      char '('
      endHead
      space
      b <- nonEmptyList funcArgExpr
      c <- optional (space1 *> sortClause)
      space
      char ')'
      space1
      d <- sconst
      return (FuncLiteral a (Just (FuncLiteralArgList b c)) d)
    ,
    FuncLiteral <$> (headify funcName <* space1) <*> pure Nothing <*> sconst
  ]

iconstOrFconst = Right <$> fconst <|> Left <$> iconst

iconst = head Lex.decimal

fconst = head Lex.float

sconst = quotedString '\''

constTypename = asum [
    NumericConstTypename <$> numeric,
    ConstBitConstTypename <$> constBit,
    ConstCharacterConstTypename <$> constCharacter,
    ConstDatetimeConstTypename <$> constDatetime
  ]

numeric = asum [
    IntegerNumeric <$ string' "integer",
    IntNumeric <$ string' "int",
    SmallintNumeric <$ string' "smallint",
    BigintNumeric <$ string' "bigint",
    RealNumeric <$ string' "real",
    FloatNumeric <$> (string' "float" *> endHead *> optional (space *> inParens iconst)),
    DoublePrecisionNumeric <$ keyphrase "double precision",
    DecimalNumeric <$> (string' "decimal" *> endHead *> optional (space *> exprListInParens)),
    DecNumeric <$> (string' "dec" *> endHead *> optional (space *> exprListInParens)),
    NumericNumeric <$> (string' "numeric" *> endHead *> optional (space *> exprListInParens)),
    BooleanNumeric <$ string' "boolean"
  ]

constBit = do
  string' "bit"
  a <- option False (True <$ space1 <* string' "varying")
  b <- optional (space1 *> exprListInParens)
  return (ConstBit a b)

constCharacter = ConstCharacter <$> (character <* endHead) <*> optional (space *> inParens iconst)

character = asum [
    CharacterCharacter <$> (string' "character" *> optVaryingAfterSpace),
    CharCharacter <$> (string' "char" *> optVaryingAfterSpace),
    VarcharCharacter <$ string' "varchar",
    NationalCharacterCharacter <$> (keyphrase "national character" *> optVaryingAfterSpace),
    NationalCharCharacter <$> (keyphrase "national char" *> optVaryingAfterSpace),
    NcharCharacter <$> (string' "nchar" *> optVaryingAfterSpace)
  ]
  where
    optVaryingAfterSpace = True <$ space1 <* string' "varying" <|> pure False

{-
ConstDatetime:
  | TIMESTAMP '(' Iconst ')' opt_timezone
  | TIMESTAMP opt_timezone
  | TIME '(' Iconst ')' opt_timezone
  | TIME opt_timezone
-}
constDatetime = asum [
    do
      string' "timestamp"
      a <- optional (space1 *> inParens iconst)
      b <- optional (space1 *> timezone)
      return (TimestampConstDatetime a b)
    ,
    do
      string' "time"
      a <- optional (space1 *> inParens iconst)
      b <- optional (space1 *> timezone)
      return (TimeConstDatetime a b)
  ]

timezone = asum [
    False <$ keyphrase "with time zone",
    True <$ keyphrase "without time zone"
  ]

interval = asum [
    YearToMonthInterval <$ keyphrase "year to month",
    DayToHourInterval <$ keyphrase "day to hour",
    DayToMinuteInterval <$ keyphrase "day to minute",
    DayToSecondInterval <$> (keyphrase "day to" *> space1 *> endHead *> intervalSecond),
    HourToMinuteInterval <$ keyphrase "hour to minute",
    HourToSecondInterval <$> (keyphrase "hour to" *> space1 *> endHead *> intervalSecond),
    MinuteToSecondInterval <$> (keyphrase "minute to" *> space1 *> endHead *> intervalSecond),
    YearInterval <$ string' "year",
    MonthInterval <$ string' "month",
    DayInterval <$ string' "day",
    HourInterval <$ string' "hour",
    MinuteInterval <$ string' "minute",
    SecondInterval <$> intervalSecond
  ]

intervalSecond = do
  string' "second"
  a <- optional (space *> inParens iconst)
  return a


-- * Types
-------------------------

{-|
>>> testParser type_ "int4"
Type "int4" False 0 False

>>> testParser type_ "int4?"
Type "int4" True 0 False

>>> testParser type_ "int4[]"
Type "int4" False 1 False

>>> testParser type_ "int4[ ] []"
Type "int4" False 2 False

>>> testParser type_ "int4[][]?"
Type "int4" False 2 True

>>> testParser type_ "int4?[][]"
Type "int4" True 2 False
-}
type_ :: Parser Type
type_ = label "type" $ do
  _baseName <- typeFuncName
  endHead
  _baseNullable <- option False (True <$ space <* char '?')
  _arrayLevels <- fmap length $ many $ space *> char '[' *> endHead *> space *> char ']'
  _arrayNullable <- option False (True <$ space <* char '?')
  return (Type _baseName _baseNullable _arrayLevels _arrayNullable)


-- * Clauses
-------------------------

{-
select_limit:
  | limit_clause offset_clause
  | offset_clause limit_clause
  | limit_clause
  | offset_clause
-}
selectLimit =
  asum
    [
      do
        _a <- limitClause
        LimitOffsetSelectLimit _a <$> (space1 *> offsetClause) <|> pure (LimitSelectLimit _a)
      ,
      do
        _a <- offsetClause
        OffsetLimitSelectLimit _a <$> (space1 *> limitClause) <|> pure (OffsetSelectLimit _a)
    ]

{-
limit_clause:
  | LIMIT select_limit_value
  | LIMIT select_limit_value ',' select_offset_value
  | FETCH first_or_next select_fetch_first_value row_or_rows ONLY
  | FETCH first_or_next row_or_rows ONLY
-}
limitClause =
  (do
    string' "limit"
    endHead
    space1
    _a <- selectLimitValue
    _b <- optional $ do
      commaSeparator
      aExpr
    return (LimitLimitClause _a _b)
  ) <|>
  (do
    string' "fetch"
    endHead
    space1
    _a <- firstOrNext
    space1
    asum [
        do
          _b <- rowOrRows
          space1
          string' "only"
          return (FetchOnlyLimitClause _a Nothing _b)
        ,
        do
          _b <- selectFetchFirstValue
          space1
          _c <- rowOrRows
          space1
          string' "only"
          return (FetchOnlyLimitClause _a (Just _b) _c)
      ]
  )

offsetClause = do
  string' "offset"
  endHead
  space1
  offsetClauseParams

offsetClauseParams =
  FetchFirstOffsetClause <$> headify selectFetchFirstValue <*> (space1 *> rowOrRows) <|>
  ExprOffsetClause <$> aExpr

{-
select_limit_value:
  | a_expr
  | ALL
-}
selectLimitValue =
  AllSelectLimitValue <$ string' "all" <|>
  ExprSelectLimitValue <$> aExpr

rowOrRows =
  True <$ string' "rows" <|>
  False <$ string' "row"

firstOrNext =
  False <$ string' "first" <|>
  True <$ string' "next"

selectFetchFirstValue =
  ExprSelectFetchFirstValue <$> cExpr <|>
  NumSelectFetchFirstValue <$> (plusOrMinus <* endHead <* space) <*> iconstOrFconst

plusOrMinus = False <$ char '+' <|> True <$ char '-'


-- * For Locking
-------------------------

{-
for_locking_clause:
  | for_locking_items
  | FOR READ ONLY
for_locking_items:
  | for_locking_item
  | for_locking_items for_locking_item
-}
forLockingClause = readOnly <|> items where
  readOnly = ReadOnlyForLockingClause <$ keyphrase "for read only"
  items = ItemsForLockingClause <$> sepWithSpace1 forLockingItem

{-
for_locking_item:
  | for_locking_strength locked_rels_list opt_nowait_or_skip
locked_rels_list:
  | OF qualified_name_list
  | EMPTY
opt_nowait_or_skip:
  | NOWAIT
  | SKIP LOCKED
  | EMPTY
-}
forLockingItem = do
  _strength <- forLockingStrength
  _rels <- optional $ space1 *> string' "of" *> space1 *> endHead *> nonEmptyList qualifiedName
  _nowaitOrSkip <- optional (space1 *> nowaitOrSkip)
  return (ForLockingItem _strength _rels _nowaitOrSkip)

{-
for_locking_strength:
  | FOR UPDATE
  | FOR NO KEY UPDATE
  | FOR SHARE
  | FOR KEY SHARE
-}
forLockingStrength =
  UpdateForLockingStrength <$ keyphrase "for update" <|>
  NoKeyUpdateForLockingStrength <$ keyphrase "for no key update" <|>
  ShareForLockingStrength <$ keyphrase "for share" <|>
  KeyForLockingStrength <$ keyphrase "for key share"

nowaitOrSkip = False <$ string' "nowait" <|> True <$ keyphrase "skip locked"


-- * References & Names
-------------------------

quotedName :: Parser Name
quotedName = filter (const "Empty name") (not . Text.null) (quotedString '"') & fmap QuotedName

{-
ident_start   [A-Za-z\200-\377_]
ident_cont    [A-Za-z\200-\377_0-9\$]
identifier    {ident_start}{ident_cont}*
-}
ident :: Parser Name
ident = quotedName <|> keywordNameByPredicate (not . Predicate.keyword)

{-
ColId:
  |  IDENT
  |  unreserved_keyword
  |  col_name_keyword
-}
{-# NOINLINE colId #-}
colId :: Parser Name
colId = ident <|> keywordNameFromSet (HashSet.unreservedKeyword <> HashSet.colNameKeyword)

{-
ColLabel:
  |  IDENT
  |  unreserved_keyword
  |  col_name_keyword
  |  type_func_name_keyword
  |  reserved_keyword
-}
colLabel :: Parser Name
colLabel = ident <|> keywordNameFromSet HashSet.keyword

{-|
>>> testParser qualifiedName "a.b"
IndirectedQualifiedName (UnquotedName "a") (AttrNameIndirectionEl (UnquotedName "b") :| [])

>>> testParser qualifiedName "a-"
...
expecting '.', '[', or end of input

>>> testParser qualifiedName "a.-"
...
expecting '*', keyword, quoted name, or white space
-}
{-
qualified_name:
  | ColId
  | ColId indirection
-}
qualifiedName :: Parser QualifiedName
qualifiedName =
  IndirectedQualifiedName <$> headify colId <*> indirection <|>
  SimpleQualifiedName <$> colId

{-
columnref:
  | ColId
  | ColId indirection
-}
columnRef = qualifiedName

{-
func_name:
  | type_function_name
  | ColId indirection
-}
funcName =
  IndirectedQualifiedName <$> headify colId <*> (space *> indirection) <|>
  SimpleQualifiedName <$> typeFuncName

{-
type_function_name:
  | IDENT
  | unreserved_keyword
  | type_func_name_keyword
-}
typeFuncName =
  ident <|>
  keywordNameFromSet (HashSet.unreservedKeyword <> HashSet.typeFuncNameKeyword)

{-
indirection:
  | indirection_el
  | indirection indirection_el
-}
indirection :: Parser Indirection
indirection = some indirectionEl

{-
indirection_el:
  | '.' attr_name
  | '.' '*'
  | '[' a_expr ']'
  | '[' opt_slice_bound ':' opt_slice_bound ']'
opt_slice_bound:
  | a_expr
  | EMPTY
-}
indirectionEl :: Parser IndirectionEl
indirectionEl =
  asum
    [
      do
        char '.'
        endHead
        space
        AllIndirectionEl <$ char '*' <|> AttrNameIndirectionEl <$> attrName
      ,
      do
        char '['
        endHead
        space
        _a <- asum [
            do
              char ':'
              endHead
              space
              _b <- optional aExpr
              return (SliceIndirectionEl Nothing _b)
            ,
            do
              _a <- aExpr
              asum [
                  do
                    space
                    char ':'
                    space
                    _b <- optional aExpr
                    return (SliceIndirectionEl (Just _a) _b)
                  ,
                  return (ExprIndirectionEl _a)
                ]
          ]
        space
        char ']'
        return _a
    ]

{-
attr_name:
  | ColLabel
-}
attrName = colLabel

keywordNameFromSet :: HashSet Text -> Parser Name
keywordNameFromSet _set = keywordNameByPredicate (Predicate.inSet _set)

keywordNameByPredicate :: (Text -> Bool) -> Parser Name
keywordNameByPredicate _predicate =
  fmap UnquotedName $
  filter
    (\ a -> "Reserved keyword " <> show a <> " used as an identifier. If that's what you intend, you have to wrap it in double quotes.")
    _predicate
    keyword

keyword :: Parser Text
keyword = head $ Mega.label "keyword" $ do
  _firstChar <- Mega.satisfy Predicate.firstIdentifierChar
  _remainder <- Mega.takeWhileP Nothing Predicate.notFirstIdentifierChar
  return (Text.toLower (Text.cons _firstChar _remainder))

{-|
Consume a keyphrase, ignoring case and types of spaces between words.
-}
keyphrase :: Text -> Parser Text
keyphrase a = Text.words a & fmap (void . Mega.string') & intersperse Mega.space1 & sequence_ & fmap (const (Text.toUpper a)) & Mega.label (show a) & head
